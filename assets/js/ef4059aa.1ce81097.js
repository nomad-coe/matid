"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[790],{3891:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var i=n(5893),s=n(1151),o=n(7416);const r="import ase.io\nfrom ase.visualize import view\n\nfrom matid.clustering import SBC\nfrom matid.symmetry import SymmetryAnalyzer\n\n# Load structure from a file\nsystem = ase.io.read('data/system.xyz')\n\n# Find interesting substructures using Symmetry-based Clustering (SBC)\nsbc = SBC()\nclusters = sbc.get_clusters(system)\n\n# Analyze each found cluster printing out the indices of the atoms belonging to\n# this cluster and visualizing the conventional cell from which the cluster was\n# built from.\nfor cluster in clusters:\n\n    # Get the indices of the atoms belonging to this cluster\n    indices = cluster.indices\n    print(indices)\n\n    # Get the dimensionality of the cluster\n    dimensionality = cluster.get_dimensionality()\n    print(dimensionality)\n\n    # Get the cell from which the cluster is constructed from. The periodicity\n    # of this cell indicates in which directions the unit cell has been found to\n    # be repeated in (at least once, possibly infinitely).\n    cell = cluster.get_cell()\n    n_repeated_directions = sum(cell.get_pbc())\n    print(n_repeated_directions)\n\n    # Analyze some symmetry properties of the underlying cell to better identify\n    # the material from which the cluster has been constructed from.\n    analyzer = SymmetryAnalyzer(cell, symmetry_tol=0.5)\n    conv_sys = analyzer.get_conventional_system()\n    view(conv_sys)\n",a={sidebar_position:1},c="Introduction",l={id:"introduction/introduction",title:"Introduction",description:"MatID is a Python package for identifying and analyzing atomistic systems based on their structure. MatID is designed to help researchers in the automated analysis and labeling of atomistic data.",source:"@site/docs/introduction/introduction.mdx",sourceDirName:"introduction",slug:"/introduction/",permalink:"/matid/docs/introduction/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/introduction/introduction.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Installation",permalink:"/matid/docs/installation/"}},d={},u=[];function m(e){const t={a:"a",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"MatID is a Python package for identifying and analyzing atomistic systems based on their structure. MatID is designed to help researchers in the automated analysis and labeling of atomistic data."}),"\n",(0,i.jsxs)(t.p,{children:["The package comes with different tools that can be connected together to form a\nworkflow for analyzing structures. Here is a brief list of the different tools\nand their functionality, you can get more details in the ",(0,i.jsx)(t.strong,{children:"Learn"})," section of\nthe docs."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"../learn/symmetry-based-clustering",children:"Symmetry-based Clustering"}),": Used to identify and report repeating structures in\nthe given atomistic system. Works both with finite and periodic systems."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"../learn/symmetry-analysis/symmetry-analyzer",children:"Symmetry Analysis"}),": Routines for analyzing the symmetry of structures. Can be used to return a highly unique conventional cell, detailed Wyckoff position information etc."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"../learn/dimensionality",children:"Dimensionality Analysis"}),": Used to determine the intended dimensionality of a system taking periodic boundary conditions into account."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"As a user, you are free to choose one or many of these tools for your analysis\npurposes. A small example that combines several of the provided tools for\nanalysing an existing structure file is shown below"}),"\n",(0,i.jsx)(o.Z,{language:"python",children:r})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);