"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[271],{2563:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=s(5893),t=s(1151);const i={sidebar_position:1,sidebar_label:"SBC Class"},l="SBC Class",o={id:"reference/sbc",title:"SBC Class",description:"Class for performing Symmetry-based clustering (SBC).",source:"@site/docs/reference/sbc.md",sourceDirName:"reference",slug:"/reference/sbc",permalink:"/matid/docs/reference/sbc",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"SBC Class"},sidebar:"docsSidebar",previous:{title:"Dimensionality Analysis",permalink:"/matid/docs/learn/dimensionality"},next:{title:"Cluster Class",permalink:"/matid/docs/reference/cluster"}},a={},c=[{value:"get_clusters",id:"get_clusters",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"sbc-class",children:"SBC Class"}),"\n",(0,r.jsx)(n.p,{children:"Class for performing Symmetry-based clustering (SBC)."}),"\n",(0,r.jsx)(n.p,{children:"You can apply this class for partitioning a larger material into grains, a\nheterostructure into it's component etc. The clustering is based on finding\nperiodically repeating motifs, and as such it is not suitable for e.g.\nfinding molecules. Any atoms that do not have enough periodic repetitions\nwill be returned as isolated clusters."}),"\n",(0,r.jsx)(n.h2,{id:"get_clusters",children:"get_clusters"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def get_clusters(system,\n                 angle_tol=20,\n                 max_cell_size=6,\n                 pos_tol=0.7,\n                 merge_threshold=0.5,\n                 merge_radius=1,\n                 bond_threshold=0.65,\n                 overlap_threshold=-0.1,\n                 radii="covalent",\n                 seed=7)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Used to detect and return structurally separate clusters within the\ngiven system."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"system"})," ",(0,r.jsx)(n.em,{children:"ase.Atoms"})," - The structure to partition."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"angle_tol"})," ",(0,r.jsx)(n.em,{children:"float"})," - angle_tol parameter for PeriodicFinder"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"max_cell_size"})," ",(0,r.jsx)(n.em,{children:"float"})," - max_cell_size parameter for PeriodicFinder.get_region"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"pos_tol"})," ",(0,r.jsx)(n.em,{children:"float"})," - pos_tol parameter for PeriodicFinder.get_region"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"merge_threshold"})," ",(0,r.jsx)(n.em,{children:"float"})," - A threshold for merging two clusters\ntogether. Give as a fraction of shared atoms. Value of 1 would\nmean that clusters are never merged, value of 0 means that they\nare merged always when at least one atom is shared."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"merge_radius"})," ",(0,r.jsx)(n.em,{children:"float"})," - Radius for finding nearby atoms when deciding\nwhich cluster is closest. The atomic radii are subtracted from\ndistances. Given in angstroms."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"bond_threshold(float)"})," - Used to control the connectivity threshold\nfor defining a chemical connection between atoms. Controls e.g.\nwhat types of unit cells are accepted and how outliers are\nremoved from clusters."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"overlap_threshold(float)"})," - Used to exclude non-physical cells by\nchecking overlap of atoms. Overlap between two atoms is\ncalculated by subtracting atomic radii from the distance between\nthe atoms."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"radii(str|np.ndarray)"})," - The radii to use for atoms. Use either a preset\nor a custom list of atomic radii for each atom. The available presets are:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"covalent: Covalent radii from DOI:10.1039/B801115J"}),"\n",(0,r.jsx)(n.li,{children:"vdw: van Der Waals radii from DOI:10.1039/C3DT50599E"}),"\n",(0,r.jsx)(n.li,{children:"vdw_covalent: preferably van Der Waals radii, covalent if vdw\nnot defined."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"seed(int)"})," - The seed that is used for random number generation."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"A list of Clusters."})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>l});var r=s(7294);const t={},i=r.createContext(t);function l(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);