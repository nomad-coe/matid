"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[871],{4954:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var i=s(5893),t=s(1151);const r={sidebar_position:4,sidebar_label:"Geometry Module"},l="Geometry Module",d={id:"reference/geometry",title:"Geometry Module",description:"This module defines functions for deriving geometry related quantities from",source:"@site/docs/reference/geometry.md",sourceDirName:"reference",slug:"/reference/geometry",permalink:"/matid/docs/reference/geometry",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"Geometry Module"},sidebar:"docsSidebar",previous:{title:"SymmetryAnalyzer Class",permalink:"/matid/docs/reference/symmetryanalyzer"},next:{title:"About",permalink:"/matid/docs/about"}},c={},a=[{value:"get_dimensionality",id:"get_dimensionality",level:2},{value:"get_tetrahedra_decomposition",id:"get_tetrahedra_decomposition",level:2},{value:"get_moments_of_inertia",id:"get_moments_of_inertia",level:2},{value:"get_center_of_mass",id:"get_center_of_mass",level:2},{value:"get_space_filling",id:"get_space_filling",level:2},{value:"make_random_displacement",id:"make_random_displacement",level:2},{value:"get_extended_system",id:"get_extended_system",level:2},{value:"get_clusters",id:"get_clusters",level:2},{value:"get_covalent_distances",id:"get_covalent_distances",level:2},{value:"get_biggest_gap_indices",id:"get_biggest_gap_indices",level:2},{value:"get_dimensions",id:"get_dimensions",level:2},{value:"get_wrapped_positions",id:"get_wrapped_positions",level:2},{value:"get_displacement_tensor_old",id:"get_displacement_tensor_old",level:2},{value:"find_mic",id:"find_mic",level:2},{value:"get_neighbour_cells",id:"get_neighbour_cells",level:2},{value:"get_mic_vector",id:"get_mic_vector",level:2},{value:"expand_pbc",id:"expand_pbc",level:2},{value:"change_basis",id:"change_basis",level:2},{value:"get_positions_within_basis",id:"get_positions_within_basis",level:2},{value:"get_matches",id:"get_matches",level:2},{value:"get_matches_new",id:"get_matches_new",level:2},{value:"get_cell_list",id:"get_cell_list",level:2},{value:"to_scaled",id:"to_scaled",level:2},{value:"to_cartesian",id:"to_cartesian",level:2},{value:"translate",id:"translate",level:2},{value:"get_closest_direction",id:"get_closest_direction",level:2},{value:"__init__",id:"__init__",level:2},{value:"add_interval",id:"add_interval",level:2},{value:"add_intervals",id:"add_intervals",level:2},{value:"set_intervals",id:"set_intervals",level:2},{value:"remove_interval",id:"remove_interval",level:2},{value:"get_intervals",id:"get_intervals",level:2},{value:"get_intervals_sorted_by_start",id:"get_intervals_sorted_by_start",level:2},{value:"get_intervals_sorted_by_end",id:"get_intervals_sorted_by_end",level:2},{value:"get_merged_intervals",id:"get_merged_intervals",level:2},{value:"get_max_distance_between_intervals",id:"get_max_distance_between_intervals",level:2},{value:"add_up_intervals",id:"add_up_intervals",level:2},{value:"add_up_merged_intervals",id:"add_up_merged_intervals",level:2},{value:"get_thickness",id:"get_thickness",level:2},{value:"get_minimized_cell",id:"get_minimized_cell",level:2},{value:"cartesian",id:"cartesian",level:2},{value:"get_crystallinity",id:"get_crystallinity",level:2},{value:"get_distances",id:"get_distances",level:2},{value:"get_radii",id:"get_radii",level:2},{value:"swap_basis",id:"swap_basis",level:2},{value:"complete_cell",id:"complete_cell",level:2}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"geometry-module",children:"Geometry Module"}),"\n",(0,i.jsx)(n.p,{children:"This module defines functions for deriving geometry related quantities from\na atomic system."}),"\n",(0,i.jsx)(n.h2,{id:"get_dimensionality",children:"get_dimensionality"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def get_dimensionality(system,\n                       cluster_threshold=CLUSTER_THRESHOLD,\n                       dist_matrix_radii_mic_1x=None,\n                       return_clusters=False,\n                       radii="covalent")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Used to calculate the dimensionality of a system with a modified\nTopology Scaling Algorithm (TSA) (Michael Ashton, Joshua Paul, Susan B.\nSinnott, and Richard G. Hennig Phys. Rev. Lett. 118, 106101)."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"system"})," ",(0,i.jsx)(n.em,{children:"ASE.Atoms"})," - The system for which the dimensionality is\nevaluated."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"cluster_threshold(float)"})," - The epsilon value for the DBSCAN algorithm\nthat is used to identify clusters within the unit cell."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dist_matrix_radii_pbc"})," ",(0,i.jsx)(n.em,{children:"np.ndarray"})," - A precalculated distance matrix\nthat takes in to account the periodicity and has the covalent radii of\nthe atoms already subtracted."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"return_clusters(boolean)"})," - Whether the clusters are returned"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"radii(str|np.ndarray)"})," - The radii to use for atoms. Use either a preset\nor a custom list or atomic radii where the atomic number is used as an\nindex. The available presets are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"covalent: Covalent radii from DOI:10.1039/B801115J"}),"\n",(0,i.jsx)(n.li,{children:"vdw: van Der Waals radii from DOI:10.1039/C3DT50599E"}),"\n",(0,i.jsx)(n.li,{children:"vdw_covalent: preferably van Der Waals radii, covalent if vdw\nnot defined."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"int|none"})," - The dimensionality of the system. If the dimensionality can't be\nevaluated because the system has multiple disconnected components in\nthe original cell, None is returned."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - A list of clusters. Each entry in the list contains the indices\nof atoms in a cluster."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_tetrahedra_decomposition",children:"get_tetrahedra_decomposition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_tetrahedra_decomposition(system, max_distance)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to decompose a series of 3D atomic coordinates into non-overlapping\ntetrahedron that together represent the atomic structure."}),"\n",(0,i.jsx)(n.h2,{id:"get_moments_of_inertia",children:"get_moments_of_inertia"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_moments_of_inertia(system, weight=True)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Calculates geometric inertia tensor, i.e., inertia tensor but with\nall masses are set to 1."}),"\n",(0,i.jsx)(n.p,{children:"I_ij = sum_k m_k (delta_ij * r_k^2 - x_ki * x_kj)\nwith r_k^2 = x_k1^2 + x_k2^2 x_k3^2"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"system(ASE Atoms): Atomic system."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"(np.ndarray, np.ndarray): The eigenvalues and eigenvectors of the\ngeometric inertia tensor."}),"\n",(0,i.jsx)(n.h2,{id:"get_center_of_mass",children:"get_center_of_mass"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_center_of_mass(system)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Calculates the center of mass and also takes the periodicity of the\nsystem into account."}),"\n",(0,i.jsxs)(n.p,{children:["The algorithm is replicated from:\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Center_of_mass#Systems_with_periodic_boundary_conditions",children:"https://en.wikipedia.org/wiki/Center_of_mass#Systems_with_periodic_boundary_conditions"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ase.Atoms)"})," - The system for which the center of mass is\ncalculated."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The cartesian positions of the center of mass in the given\nsystem."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_space_filling",children:"get_space_filling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_space_filling(system)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Calculates the ratio of vacuum to filled space by assuming covalent\nradii for the atoms."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - Atomic system."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"float"})," - The ratio of occupied volume to the cell volume."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"make_random_displacement",children:"make_random_displacement"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def make_random_displacement(system, delta, rng=None)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Dislocate every atom in the given system in a random direction but by\nthe same amount. Uses an internal random number generator to avoid touching\nthe global numpy.random.seed()-function."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - The system for which the displacement are performed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"delta(float)"})," - The magnitude of the displacements."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rng(np.random.RandomState)"})," - Random number generator."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_extended_system",children:"get_extended_system"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_extended_system(system, cutoff=0)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a system and a cutoff value, returns a new system which has been\nextended so that for each atom the neighbourhood within the cutoff radius is\npresent, taking periodic boundary conditions into account."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - System to extend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cutoff(float)"})," - Radial cutoff"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"ExtendedSystem object."}),"\n",(0,i.jsx)(n.h2,{id:"get_clusters",children:"get_clusters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_clusters(dist_matrix, threshold, min_samples=1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to detect clusters with the DBSCAN algorithm."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dist_matrix(np.ndarray)"})," - The 2D distance matrix from which the clusters\nare calculated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"threshold(float)"})," - The epsilon threshold value for the clustering"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"min_samples(int)"})," - The minimum allowed cluster size."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - A list of clusters, where each cluster is a list of indices for\nthe elements belonging to the cluster."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_covalent_distances",children:"get_covalent_distances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_covalent_distances(system, mic=True)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns a distance matrix where the covalent radii have been taken into\naccount. Clips negative values to be zero."}),"\n",(0,i.jsx)(n.h2,{id:"get_biggest_gap_indices",children:"get_biggest_gap_indices"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_biggest_gap_indices(coordinates)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given the list of coordinates for one axis, this function will find the\nmaximum gap between them and return the index of the bottom and top\ncoordinates. The bottom and top are defined as:"}),"\n",(0,i.jsx)(n.p,{children:"===       ===============    ---\x3e\n^top    ^bot               ^axis direction"}),"\n",(0,i.jsx)(n.h2,{id:"get_dimensions",children:"get_dimensions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_dimensions(system, vacuum_gaps)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a system with vacuum gaps, calculate its dimensions in the\ndirections with vacuum gaps by also taking into account the atomic radii."}),"\n",(0,i.jsx)(n.h2,{id:"get_wrapped_positions",children:"get_wrapped_positions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_wrapped_positions(scaled_pos, precision=1e-5)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Wrap the given relative positions so that each element in the array\nis within the half-closed interval [0, 1)"}),"\n",(0,i.jsx)(n.p,{children:"By wrapping values near 1 to 0 we will have a consistent way of\npresenting systems."}),"\n",(0,i.jsx)(n.h2,{id:"get_displacement_tensor_old",children:"get_displacement_tensor_old"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_displacement_tensor_old(pos1,\n                                pos2,\n                                cell=None,\n                                pbc=None,\n                                mic=False,\n                                cutoff=None,\n                                return_factors=False,\n                                return_distances=False)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given an array of positions, calculates the 3D displacement tensor\nbetween the positions."}),"\n",(0,i.jsx)(n.p,{children:"The displacement tensor is a matrix where the entry A[i, j, :] is the\nvector pos1[i] - pos2[j], i.e. the vector from pos2 to pos1"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pos1(np.ndarray)"})," - 2D array of positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pos2(np.ndarray)"})," - 2D array of positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cell(np.ndarray)"})," - Cell for taking into account the periodicity\npbc(boolean or a list of booleans): Periodicity of the axes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mic(boolean)"})," - Whether to return the displacement to the nearest\nperiodic copy"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - 3D displacement tensor\n(optional) np.ndarray: The indices of the periodic copies in which the\nminimum image was found\n(optional) np.ndarray: The lengths of the displacement vectors"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"find_mic",children:"find_mic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def find_mic(D, cell, pbc, max_distance=None)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Finds the minimum-image representation of vector(s) D."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"D(np.ndarray)"})," - A nx3 array of vectors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cell(np.ndarray)"})," - A valid ase Atoms cell definition."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pbc(np.ndarray)"})," - A 3x1 boolean array for the periodic boundary\nconditions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mic_copies(np.ndarray)"})," - The maximum number of periodic copies to\nconsider in each direction. If not specified, the maximum possible\nnumber of copies is determined and used."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The minimum image versions of the given vectors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The shifts corresponding to the indices of the neighbouring\ncells in which the vectors were found."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_neighbour_cells",children:"get_neighbour_cells"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_neighbour_cells(cell, cutoff, pbc)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a cell and a cutoff, returns the indices of the copies of the cell\nwhich have to be searched in order to reach atom within the cutoff\ndistance."}),"\n",(0,i.jsx)(n.p,{children:"The number of neighboring images to search in each direction is equal to\nthe ceiling of the cutoff distance (defined above) divided by the length of\nthe projection of the lattice vector onto its corresponding surface normal.\na's surface normal vector is e.g.  b x c / (|b| |c|), so this projection is\n(a . (b x c)) / (|b| |c|).  The numerator is just the lattice volume, so\nthis can be simplified to V / (|b| |c|). This is rewritten as V |a| / (|a|\n|b| |c|) for vectorization purposes."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.h2,{id:"get_mic_vector",children:"get_mic_vector"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_mic_vector(w, v, cell)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to calculate the minimum image version of a vector in the given\ncell."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rel_vector(np.ndarray)"})," - Relative vector in the cell basis:"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The MIC version of the given vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The shift that corresponds to the neighbouring cell in\nwhich the copy was found."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"expand_pbc",children:"expand_pbc"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def expand_pbc(pbc)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to expand a pbc definition into an array of three booleans."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"pbc(boolean or a list of booleans): The periodicity of the cell. This\ncan be any of the values that is also supprted by ASE, namely: a\nboolean or a list of three booleans."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"np.ndarray of booleans: The periodicity expanded as an explicit list of\nthree boolean values."}),"\n",(0,i.jsx)(n.h2,{id:"change_basis",children:"change_basis"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def change_basis(positions, basis, offset=None)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Transform the given cartesian coordinates to a basis that is defined by\nthe given basis and origin offset."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"positions(np.ndarray)"})," - Positions in cartesian coordinates."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"basis(np.ndarray)"})," - Basis to which to transform."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"offset(np.ndarray)"})," - Offset of the origins. A vector from the old basis\norigin to the new basis origin."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - Relative positions in the new basis"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_positions_within_basis",children:"get_positions_within_basis"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_positions_within_basis(system,\n                               basis,\n                               origin,\n                               tolerance,\n                               mask=[True, True, True],\n                               pbc=True)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to return the indices of positions that are inside a certain basis.\nAlso takes periodic boundaries into account."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - System from which the positions are searched."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"basis(np.ndarray)"})," - New basis vectors."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"origin(np.ndarray)"})," - New origin of the basis in cartesian coordinates."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tolerance(float)"})," - The matching tolerance in angstrom.\nmask(sequence of bool): Mask for selecting the basis's to consider.\npbc(sequence of bool): The periodicity of the system."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"sequence of int: Indices of the atoms within this cell in the given\nsystem."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - Relative positions of the found atoms."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The index of the periodic copy in which the position was\nfound."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_matches",children:"get_matches"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_matches(system, positions, numbers, tolerances, mic=True)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a system and a list of cartesian positions and atomic numbers,\nreturns a list of indices for the atoms corresponding to the given\npositions with some tolerance."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - System where to search the positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"positions(np.ndarray)"})," - Positions to match in the system."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tolerances(np.ndarray)"})," - Maximum allowed distance for each vector that\nis allowed for a match in position."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mic(boolean)"})," - Whether to find the minimum image copy."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - indices of matched atoms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - list of substitutions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - list of vacancies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - for each searched position, an integer array representing\nthe number of the periodic copy where the match was found."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_matches_new",children:"get_matches_new"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_matches_new(system, cell_list, positions, numbers, tolerances)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a system and a list of cartesian positions and atomic numbers,\nreturns a list of indices for the atoms corresponding to the given\npositions with some tolerance."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - System where to search the positions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cell_list(CellList)"})," - The cell list for an appropriately extended version\nof the system."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"positions(np.ndarray)"})," - Positions to match in the system."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tolerances(np.ndarray)"})," - Maximum allowed distance for each vector that\nis allowed for a match in position."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - indices of matched atoms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - list of substitutions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"list"})," - list of vacancies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - for each searched position, an integer array representing\nthe number of the periodic copy where the match was found."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_cell_list",children:"get_cell_list"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_cell_list(positions, indices, factors, cutoff=0)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given a system and a cutoff value, returns a cell list object."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - System to extend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cutoff(float)"})," - Radial cutoff"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"CellList object."}),"\n",(0,i.jsx)(n.h2,{id:"to_scaled",children:"to_scaled"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def to_scaled(cell, positions, wrap=False, pbc=False)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to transform a set of positions to the basis defined by the\ncell of this system."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ASE.Atoms)"})," - Reference system."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"positions"})," ",(0,i.jsx)(n.em,{children:"numpy.ndarray"})," - The positions to scale"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"wrap"})," ",(0,i.jsx)(n.em,{children:"numpy.ndarray"})," - Whether the positions should be wrapped\ninside the cell."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"numpy.ndarray"})," - The scaled positions"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"to_cartesian",children:"to_cartesian"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def to_cartesian(cell, scaled_positions, wrap=False, pbc=False)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to transform a set of relative positions to the cartesian basis\ndefined by the cell of this system."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cell"})," ",(0,i.jsx)(n.em,{children:"numpy.ndarray"})," - 3x3 array with lattice vectors as rows."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"positions"})," ",(0,i.jsx)(n.em,{children:"numpy.ndarray"})," - The positions to scale. These postiions\nshould have a shape of [n, 3], where n is the number of positions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"wrap"})," ",(0,i.jsx)(n.em,{children:"numpy.ndarray"})," - Whether the positions should be wrapped\ninside the cell."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"numpy.ndarray"})," - The cartesian positions"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"translate",children:"translate"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def translate(system, translation, relative=False)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Translates the positions by the given translation."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"translation"})," ",(0,i.jsx)(n.em,{children:"1x3 numpy.array"})," - The translation to apply."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"relative"})," ",(0,i.jsx)(n.em,{children:"bool"})," - True if given translation is relative to cell\nvectors."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_closest_direction",children:"get_closest_direction"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_closest_direction(vec, directions, normalized=False)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to return the direction that is most parallel to a given one."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.h1,{id:"intervals-class",children:"Intervals Class"}),"\n",(0,i.jsx)(n.p,{children:"Handles list of intervals."}),"\n",(0,i.jsx)(n.p,{children:"This class allows sorting and adding up of intervals and taking into\naccount if they overlap."}),"\n",(0,i.jsx)(n.h2,{id:"__init__",children:"__init__"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def __init__(intervals=None)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"intervals"})," - List of intervals that are added."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"add_interval",children:"add_interval"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_interval(a, b)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add one interval."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"a, b: Start and end of interval. The order does not matter."}),"\n",(0,i.jsx)(n.h2,{id:"add_intervals",children:"add_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_intervals(intervals)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Add list of intervals."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"intervals"})," - List of intervals that are added."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"set_intervals",children:"set_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def set_intervals(intervals)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Set list of intervals."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"intervals"})," - List of intervals that are set."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"remove_interval",children:"remove_interval"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def remove_interval(i)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Remove one interval."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"i"})," - Index of interval that is removed."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_intervals",children:"get_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_intervals()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the intervals."}),"\n",(0,i.jsx)(n.h2,{id:"get_intervals_sorted_by_start",children:"get_intervals_sorted_by_start"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_intervals_sorted_by_start()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns list with intervals ordered by their start."}),"\n",(0,i.jsx)(n.h2,{id:"get_intervals_sorted_by_end",children:"get_intervals_sorted_by_end"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_intervals_sorted_by_end()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns list with intervals ordered by their end."}),"\n",(0,i.jsx)(n.h2,{id:"get_merged_intervals",children:"get_merged_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_merged_intervals()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns list of merged intervals so that they do not overlap anymore."}),"\n",(0,i.jsx)(n.h2,{id:"get_max_distance_between_intervals",children:"get_max_distance_between_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_max_distance_between_intervals()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the maximum distance between the intervals while accounting for overlap."}),"\n",(0,i.jsx)(n.h2,{id:"add_up_intervals",children:"add_up_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_up_intervals()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the added up lengths of intervals without accounting for overlap."}),"\n",(0,i.jsx)(n.h2,{id:"add_up_merged_intervals",children:"add_up_merged_intervals"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def add_up_merged_intervals()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the added up lengths of merged intervals in order to account for overlap."}),"\n",(0,i.jsx)(n.h2,{id:"get_thickness",children:"get_thickness"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_thickness(system, axis)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get the thickness of an atomic system along a basis vector direction."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ase.Atoms)"})," - The system from which the thickness is evaluated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"axis(int)"})," - The index of the unit cell basis in which direction the\nthickness is evaluated."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"float"})," - The thickness of the system as measured from the center of the\ntopmost atom to the center of lowermost atom."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_minimized_cell",children:"get_minimized_cell"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_minimized_cell(system, axis, min_size)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to resize the cell in the given cell direction so that all atoms\nare within the cell."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system(ase.Atoms)"})," - The system to minimize. Must have a cell with\nnon-zero volume."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"axis(int)"})," - Index of the axis to minimize."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"axis(min_size)"})," - The minimum size for the cell in the given direction."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ase.Atoms"})," - The new minimized system."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cartesian",children:"cartesian"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def cartesian(arrays, out=None)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Generate a cartesian product of input arrays."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"arrays(sequence of arrays): The arrays from which the product is\ncreated."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"out(ndarray)"})," - Array to place the cartesian product in."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ndarray"})," - 2-D array of shape (M, len(arrays)) containing cartesian\nproducts formed of input arrays."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"cartesian(([1, 2, 3], [4, 5], [6, 7]))\narray([[1, 4, 6],\n[1, 4, 7],\n[1, 5, 6],\n[1, 5, 7],\n[2, 4, 6],\n[2, 4, 7],\n[2, 5, 6],\n[2, 5, 7],\n[3, 4, 6],\n[3, 4, 7],\n[3, 5, 6],\n[3, 5, 7]])"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"get_crystallinity",children:"get_crystallinity"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_crystallinity(symmetry_analyser)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Quantifies the crystallinity of the structure as a ratio of symmetries\nper number of unique atoms in primitive cell. This metric can be used to\ndistinguish between amorphous and 'regular' crystals."}),"\n",(0,i.jsx)(n.p,{children:"The number of symmetry operations corresponds to the symmetry operations\ncorresponding to the hall number of the structure. The symmetry operations\nas given by spglib.get_symmetry() are specific to the original structure,\nand they have not been reduced to the symmetries of the space group."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"symmetry_analyser (): A SymmetryAnalyzer object that has been\ninitialized with an atomic structure."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"(float) A ratio of symmetries per unique atoms in the primitive cell."}),"\n",(0,i.jsx)(n.h2,{id:"get_distances",children:"get_distances"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def get_distances(system: Atoms, radii="covalent") -> Distances\n'})}),"\n",(0,i.jsx)(n.p,{children:"Returns complete distance information."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"system"})," - The system from which distances are calculated from."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"A Distances instance."}),"\n",(0,i.jsx)(n.h2,{id:"get_radii",children:"get_radii"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_radii(radii, atomic_numbers=None) -> np.ndarray\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns an array of atomic radii for each atom."}),"\n",(0,i.jsx)(n.h2,{id:"swap_basis",children:"swap_basis"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def swap_basis(atoms: Atoms, a: int, b: int)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Used to swap two bases in a system. The geometry remains identical."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a"})," - First index to swap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"b"})," - Second index to swap"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"complete_cell",children:"complete_cell"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def complete_cell(a, b, length)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Given two basis vectors a and b, creates a third one that is\northogonal and has the length of 2 * maximum 2D cell height."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a(np.ndarray)"})," - First basis vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"b(np.ndarray)"})," - Second basis vector"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"length(float)"})," - Length of the basis"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"np.ndarray"})," - The third basis vector"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>d,a:()=>l});var i=s(7294);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);