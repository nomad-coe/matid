"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[911],{2873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var s=n(5893),i=n(1151),r=n(7416);const a="import ase.io\nfrom ase.visualize import view\n\nfrom matid.clustering import SBC\nfrom matid.symmetry import SymmetryAnalyzer\n\n# Load structure from a file\nsystem = ase.io.read('data/system.xyz')\n\n# Find interesting substructures using Symmetry-based Clustering (SBC)\nsbc = SBC()\nclusters = sbc.get_clusters(system)\n\n# Analyze each found cluster printing out the indices of the atoms belonging to\n# this cluster and visualizing the conventional cell from which the cluster was\n# built from.\nfor cluster in clusters:\n\n    # Get the indices of the atoms belonging to this cluster\n    indices = cluster.indices\n    print(indices)\n\n    # Get the dimensionality of the cluster\n    dimensionality = cluster.get_dimensionality()\n    print(dimensionality)\n\n    # Get the cell from which the cluster is constructed from. The periodicity\n    # of this cell indicates in which directions the unit cell has been found to\n    # be repeated in (at least once, possibly infinitely).\n    cell = cluster.get_cell()\n    n_repeated_directions = sum(cell.get_pbc())\n    print(n_repeated_directions)\n\n    # Analyze some symmetry properties of the underlying cell to better identify\n    # the material from which the cluster has been constructed from.\n    analyzer = SymmetryAnalyzer(cell, symmetry_tol=0.5)\n    conv_sys = analyzer.get_conventional_system()\n    view(conv_sys)\n",o={sidebar_position:1},c="Quick Start",l={id:"get-started/quick-start",title:"Quick Start",description:"MatID is a Python package for identifying and analyzing atomistic systems based",source:"@site/docs/get-started/quick-start.md",sourceDirName:"get-started",slug:"/get-started/quick-start",permalink:"/matid/docs/get-started/quick-start",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",next:{title:"Installation",permalink:"/matid/docs/get-started/installation"}},d={},u=[];function m(e){const t={a:"a",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(t.p,{children:"MatID is a Python package for identifying and analyzing atomistic systems based\non their structure. MatID is designed to help researchers in the automated\nanalysis and labeling of atomistic data."}),"\n",(0,s.jsxs)(t.p,{children:["The package comes with different tools that can be connected together to form a\nworkflow for analyzing structures. The ",(0,s.jsx)(t.strong,{children:"Learn"})," section contains documentation\nthat helps you get to know the basic functionality of the package, most\nimportantly:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/docs/learn/symmetry-based-clustering",children:"Symmetry-based Clustering"}),": Learn how to identify and report repeating structures in\natomistic system. Works both with finite and periodic systems."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/docs/learn/symmetry-analysis",children:"Symmetry Analysis"}),": Routines for analyzing the symmetry of structures. Can be used to return a highly unique conventional cell, detailed Wyckoff position information etc."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/docs/learn/dimensionality",children:"Dimensionality Analysis"}),": Used to determine the intended dimensionality of a system taking periodic boundary conditions into account."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"As a user, you are free to choose one or many of these tools for your analysis\npurposes. A small example that combines several of the provided tools for\nanalysing an existing structure file is shown below"}),"\n",(0,s.jsx)(r.Z,{language:"python",children:a}),"\n",(0,s.jsxs)(t.p,{children:["To learn more about the exact call signature of classes and functions, visit the\ndocuments in the ",(0,s.jsx)(t.strong,{children:"Reference"})," section. It contains autogenerated documentation\nfor the key classes and modules."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}}}]);