"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[162],{8971:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var i=n(5893),s=n(1151),r=n(7416);const a="import ase.io\nfrom ase.visualize import view\n\nfrom matid.clustering import SBC\nfrom matid.symmetry import SymmetryAnalyzer\n\n# Load structure from a file\nsystem = ase.io.read('data/system.xyz')\n\n# Find interesting substructures using Symmetry-based Clustering (SBC)\nsbc = SBC()\nclusters = sbc.get_clusters(system)\n\n# Analyze each found cluster printing out the indices of the atoms belonging to\n# this cluster and visualizing the conventional cell from which the cluster was\n# built from.\nfor cluster in clusters:\n\n    # Get the indices of the atoms belonging to this cluster\n    indices = cluster.indices\n    print(indices)\n\n    # Get the dimensionality of the cluster\n    dimensionality = cluster.get_dimensionality()\n    print(dimensionality)\n\n    # Get the cell from which the cluster is constructed from. The periodicity\n    # of this cell indicates in which directions the unit cell has been found to\n    # be repeated in (at least once, possibly infinitely).\n    cell = cluster.get_cell()\n    n_repeated_directions = sum(cell.get_pbc())\n    print(n_repeated_directions)\n\n    # Analyze some symmetry properties of the underlying cell to better identify\n    # the material from which the cluster has been constructed from.\n    analyzer = SymmetryAnalyzer(cell, symmetry_tol=0.5)\n    conv_sys = analyzer.get_conventional_system()\n    view(conv_sys)\n",o={sidebar_position:1},l="Getting started",c={id:"getting-started",title:"Getting started",description:"MatID is a Python package for identifying and analyzing atomistic systems based",source:"@site/docs/getting-started.md",sourceDirName:".",slug:"/getting-started",permalink:"/matid/docs/getting-started",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",next:{title:"Installation",permalink:"/matid/docs/learn/installation"}},d={},h=[{value:"Reference",id:"reference",level:2}];function m(e){const t={a:"a",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"getting-started",children:"Getting started"}),"\n",(0,i.jsx)(t.p,{children:"MatID is a Python package for identifying and analyzing atomistic systems based\non their structure. MatID is designed to help researchers in the automated\nanalysis and labeling of atomistic data."}),"\n",(0,i.jsx)(t.h1,{id:"learn",children:"Learn"}),"\n",(0,i.jsx)(t.p,{children:'The package comes with different tools that can be connected together to form a\nworkflow for analyzing structures. The "Learn" section contains documentation\nthat helps you get to know the basic functionality of the package, most\nimportantly:'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/learn/symmetry-based-clustering",children:"Symmetry-based Clustering"}),": Learn how to identify and report repeating structures in\natomistic system. Works both with finite and periodic systems."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/learn/symmetry-analysis",children:"Symmetry Analysis"}),": Routines for analyzing the symmetry of structures. Can be used to return a highly unique conventional cell, detailed Wyckoff position information etc."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"/docs/learn/dimensionality",children:"Dimensionality Analysis"}),": Used to determine the intended dimensionality of a system taking periodic boundary conditions into account."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"As a user, you are free to choose one or many of these tools for your analysis\npurposes. A small example that combines several of the provided tools for\nanalysing an existing structure file is shown below"}),"\n",(0,i.jsx)(r.Z,{language:"python",children:a}),"\n",(0,i.jsx)(t.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsx)(t.p,{children:'To learn more about the exact call signature of classes and functions, visit the\ndocuments in the "Reference" section. It contains autogenerated documentation\nfor the key classes and modules.'})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);